[{"title":"JavaScript this的四种绑定方式","url":"/2019/01/03/JavaScript-this的四种绑定方式/","content":"\n# JavaScript函数中`this`的四种绑定\n\n[TOC]\n\n\n\n## `this`的四种绑定\n\n\n\n- 默认绑定\n- 隐式绑定\n- 显式绑定\n- new绑定\n\n\n\n### 1. 默认绑定\n\n\n\n当一个函数没有明确的**调用对象**的时候，也就是单纯作为独立函数调用的时候，将对函数的`this`使用默认绑定：绑定到全局的`window`对象\n\n\n\n如果在严格模式下（`use strict`），`this`会指向`undefined`\n\n\n\n```javascript\n// 第一个例子\nvar foo = function() {\n    console.log(this.a);\n}\nvar a = 2;\nfoo(); // 2 \n```\n\n\n\n```javascript\n// 第二个例子\nvar foo = function() {\n    var a =3;\n    var inner = function() {\n        console.log(this.a);\n    }\n    inner();\n}\nvar a = 2;\nfoo(); // 2\n```\n\n\n\n第二个例子虽然在`foo()`的作用域内声明了`a = 3`，但它并不是一个对象，所以`this`最终还是指向了`window`对象。\n\n\n\n### 2.隐式绑定\n\n\n\n函数被调用时有上下文对象，那么`this`会绑定这个上下文对象。\n\n也就是： **当函数被一个对象包含的时候，我们称这个函数的`this`被隐式绑定到这个对象上了**\n\n\n\n```javascript\n// 例子\nvar o = {\n    a: 2,\n    foo: function() {\n        console.log(this.a);\n    }\n};\no.foo(); // 2\n```\n\n\n\n**在一串对象属性引用链中，`this`绑定的是最内层的对象**\n\n\n\n```javascript\n// 例子2\nvar obj = {\n    a: 1,\n    obj2: {\n        a:2,\n        obj3: {\n            a:3,\n            getA: function() {\n                console.log(this.a);\n            }\n        }\n    }\n}\n\nobj.obj2.obj3.getA();   // 3\n```\n\n\n\n#### 隐式丢失\n\n最常见的`this`绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是它会应用默认绑定，把`this`绑定到全局对象或者`undefined`上\n\n\n\n```javascript\n// 例子\nvar foo = function() {\n    console.log(this.a);\n}\nvar obj = {\n    a:2,\n    foo: foo\n}\nvar a = 5;\nvar bar = obj.foo;\nbar() // 5\nobj.foo(); // 2\n```\n\n像这个例子，**obj对象把foo函数引用传给bar的时候，会丢失`this`对obj的绑定。**\n\n\n\n**回调函数同样也会丢失绑定。**\n\n```javascript\nvar foo = function() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 2,\n    foo: foo\n}\nvar a = 5;\nsetTimeout(obj.foo, 100); // 5\n```\n\n\n\n\n\n**这种函数赋值的方式是无法将函数所绑定的this对象也传递过去的**\n\n那如果我就是想传递函数并且把所绑定的this对象也传递过去呢？\n那么你可以使用显式绑定，当然还有别的办法，ES6中的箭头函数，以及很常用的`var self = this`。\n\n可以参考这篇文章[解决隐式丢失问题的办法](https://blog.csdn.net/qq799028706/article/details/85545192)\n\n\n\n\n\n### 3.显式绑定\n\n\n\n显式绑定式通过`apply`或者`call`函数绑定的对象。\n\n如果你想传递函数并且把所绑定的`this`对象也传递过去，那么就可以使用`call()`\n\n```javascript\nfn.call(object)\n// fn是你调用的函数\n// object是你希望绑定的对象\n// 作用：即刻调用函数fn(),调用时这个函数的this指向object\n```\n\n\n\n```javascript\n// 例子\nvar foo = function() {\n    console.log(this.a);\n}\nvar obj = {\n    a:1\n}\nfoo.call(obj); // 1\n```\n\n\n\n这样做有个缺点，每次调用都会依赖`call`。\n\n所以可以将他包装成函数。\n\n```javascript\nvar foo = function() {\n\tconsole.log(this.a);\n}\nvar obj = {\n    a:1\n}\nvar bar = funtion() {\n    foo.call(obj)\n}\n\nbar();\n```\n\n\n\n如果使用`bind`会更简单\n\n```javascript\nvar foo = function (){\n    console.log(this.a);\n}\n\nvar obj = 1{\n    a:1\n}\n\nvar bar = foo.bind(obj);\nbar();\n```\n\n\n\n`call`和`bind`的区别是——在绑定到`this`对象参数的同时：\n\n1. `call`将立即执行该函数。\n2. `bind`不执行函数，只返回一个可供执行的函数。\n\n\n\n### `new`绑定\n\n\n\n用`new`来调用函数，会自动执行下列操作：\n\n1. 创建一个全新的对象\n2. 这个新对象被执行`[[prototype]]`连接\n3. 这个新对象会绑定到函数调用的`this`\n4. 如果函数没有返回其他对象，那么`new`表达式中的函数调用会自动返回这个新对象\n\n\n\n```javascript\n// 例子\nfunction foo(a) {\n    this.a = a;\n}\n\nvar bar = new foo(2);\n\nconsole.log(bar.a);\n```\n\n\n\n### 优先级\n\n\n\n**`new`绑定 -> 显式绑定 -> 隐式绑定 -> 默认绑定"},{"title":"Hello World","url":"/2018/12/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]