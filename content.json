{"meta":{"title":"CYoung","subtitle":null,"description":"The day is Tody.","author":"C. Young","url":"https://cuiyiming1998.github.io"},"pages":[{"title":"about","date":"2019-01-03T11:35:45.000Z","updated":"2019-01-06T09:16:39.816Z","comments":true,"path":"about/index-1.html","permalink":"https://cuiyiming1998.github.io/about/index-1.html","excerpt":"","text":"Hello World!"},{"title":"categories","date":"2019-01-03T11:36:01.000Z","updated":"2019-01-03T11:36:01.630Z","comments":true,"path":"categories/index-1.html","permalink":"https://cuiyiming1998.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"About","date":"2018-12-25T09:15:30.000Z","updated":"2019-01-06T09:17:36.108Z","comments":true,"path":"about/index.html","permalink":"https://cuiyiming1998.github.io/about/index.html","excerpt":"","text":"Hello World!"},{"title":"categories","date":"2018-12-25T10:05:35.000Z","updated":"2018-12-25T10:05:35.870Z","comments":true,"path":"categories/index.html","permalink":"https://cuiyiming1998.github.io/categories/index.html","excerpt":"","text":""},{"title":"gallery","date":"2018-12-25T10:05:59.000Z","updated":"2018-12-25T10:05:59.785Z","comments":true,"path":"gallery/index.html","permalink":"https://cuiyiming1998.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-03T11:36:12.000Z","updated":"2019-01-03T11:36:12.046Z","comments":true,"path":"tags/index-1.html","permalink":"https://cuiyiming1998.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-25T09:15:24.000Z","updated":"2018-12-25T09:16:35.648Z","comments":true,"path":"tags/index.html","permalink":"https://cuiyiming1998.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node.js Stream-流","slug":"Node-js-Stream-流","date":"2019-01-06T08:23:10.000Z","updated":"2019-01-06T13:41:40.272Z","comments":true,"path":"2019/01/06/Node-js-Stream-流/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/06/Node-js-Stream-流/","excerpt":"","text":"Stream是一个抽象接口，Node中有很多对象实现了这个借口。例如对http服务器发起请求的request对象就是一个Stream，还有stdout（标准输出）。 Node.js Stream有四种流类型： Readable -&gt; 可读操作。 Writable - &gt; 可写操作。 Duplex - &gt; 可读可写操作。 Transform - &gt; 操作被写入数据，然后读出结果。 所有的Stream对象都是EventEmitter的实例。常用的事件有： data -&gt; 当有数据可读时触发。 end - &gt; 没有更多的数据可读时触发。 error - &gt; 在接收和写入过程中发生错误时触发。 finish - &gt; 所有数据已被写入到底层系统时触发。 从流中读取数据创建input.txt文件，内容如下： 百度：www.baidu.com 创建main.js文件，内容如下： var fs = require('fs'); var data = ''; // 创建可读流 var readerStream = fs.createReadStream('input.txt'); // 设置编码为utf-8 readerStream.setEncoding('UTF8'); // 处理流事件 --> data, end, error rederStream.on('data', function(chunk){ data += chunk; }); readerStream.on('end', function() { console.log(data); }); readerStream.on('error', function(err){ console.log(err.stack); }); console.log('程序执行完毕'); 执行代码后结果如下： 程序执行完毕 百度： www.baidu.com 写入流创建main.js文件，代码如下： var fs = require(\"fs\"); var data = '百度：www.baidu.com'; // 创建一个可以写入的流，写入到文件 output.txt 中 var writerStream = fs.createWriteStream('output.txt'); // 使用 utf8 编码写入数据 writerStream.write(data,'UTF8'); // 标记文件末尾 writerStream.end(); // 处理流事件 --> data, end, and error writerStream.on('finish', function() { console.log(\"写入完成。\"); }); writerStream.on('error', function(err){ console.log(err.stack); }); console.log(\"程序执行完毕\"); 以上程序会将data变量的数据写入到output.txt中。代码执行结果如下； $ node main.js 程序执行完毕 写入完成。 查看output.txt文件的内容： $ cat output.txt 百度：www.baidu.com 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。 我们把文件比作装水的桶，而内容就是桶中的水，我们用一根管道（pipe）链接两个水桶，使得一个水桶里的水可以流入另一个桶。这样就慢慢的实现了大文件的复制过程。 设置input.txt文件内容如下： 百度：www.baidu.com 管道流操作实例 创建main.js文件，代码如下： var fs = require('fs'); // 创建一个可读流 var readerStream = fs.createReadStream('input.txt'); // 创建一个可写流 var writerStrean = fs.createWriteStream('output.txt'); // 管道读写操作 // 读取input.txt的内容，并将内容写入到output.txt文件中。 readerStream.pipe(writeStream); console.log('程序执行完毕') 执行后，查看output.txt的内容： 百度：www.baidu.com 管道流操作实例 链式流链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。 接下来我们就是用管道和链式来压缩和解压文件。 创建compress.js文件，代码如下： var fs = require(\"fs\"); var zlib = require('zlib'); // 压缩 input.txt 文件为 input.txt.gz fs.createReadStream('input.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('input.txt.gz')); console.log(\"文件压缩完成。\"); 压缩完成。 创建decompress.js文件，代码如下； var fs = require(\"fs\"); var zlib = require('zlib'); // 解压 input.txt.gz 文件为 input.txt fs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('input.txt')); console.log(\"文件解压完成。\"); 解压完成。 参考于 www.runoob.com","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://cuiyiming1998.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://cuiyiming1998.github.io/tags/Node-js/"}]},{"title":"Node.js EventEmitter","slug":"Node-js-EventEmitter","date":"2019-01-04T09:05:24.000Z","updated":"2019-01-06T13:42:11.866Z","comments":true,"path":"2019/01/04/Node-js-EventEmitter/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/04/Node-js-EventEmitter/","excerpt":"","text":"node.js所有的异步I/O操作在完成时都会发送一个事件到事件队列。 Node.js里面的许多对象都会分发事件： 一个net.server对象会在每次有新连接时触发一个事件，一个fs.ReadStream对象会在文件被打开的时候触发一个事件。所有这些产生事件的对象都是events.EventEmitter的实例。 EventEmitter类events模块只提供了一个对象：events.EventEmitter。EventEmitter的核心就是事件触发与事件监听器功能的封装。 你可以通过require(&quot;events&quot;)来访问该模块。 // 引入 events 模块 var events = require('events'); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); EventEmitter对象如果在实例化时发生错误，会发生error事件。当添加新的监听器时，newListener会被触发；当监听器被移除时，removeListener事件会被触发。 EventEmitter的用法var EventEmitter = require('events').EventEmitter; var event = new EventEmitter(); event.on('some_event', funcion(){ console.log('some_event 事件触发'); }); setTimeout(function() { event.emit('some_event'); },1000); 执行结果如下： $ node event.js some_event 事件触发 运行这段代码，一秒后控制台输出了&#39;some_event 事件触发&#39;。其原理是event对象注册了事件some_event的一个监听器，然后我们通过setTimeout在1000毫秒以后向event对象发送事件some_event，此时会调用some_event的监听器。 EventEmitter的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter支持若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 让我们以下面的例子解释这个过程： var events = require('events'); var emitter = new events.EventEmitter(); emitter.on('someEvent', function(arg1, arg2) { console.log('listener1', arg1, arg2); }); emitter.on('someEvent', function(arg1, arg2) { console.log('listener2', arg1, arg2); }); emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 以上例子中，emitter为事件 someEvent注册了两个事件监听器，然后触发了 someEvent事件。 运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法addListener(event,listener)为指定事件添加一个监听器到监听器数组的尾部。 on(event,listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 server.on('connection', function(stream) { console.log('someone connected!'); }); once(event,listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。 server.once('connection', function(stream) { console.log('Ah, we have our first user!'); }); removeListener(event,listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 它接受两个参数，第一个是事件名称，第二个是回调函数名称。 var callback = function(stream) { console.log('someone connected!'); }; server.on('connection',callback); // .. server.removeListener('connection',callback); // 移除事件监听器 removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event)返回指定事件的监听器数组。 emit(event, [arg1], [arg2], [...])按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 参考于 www.runoob.com","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://cuiyiming1998.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://cuiyiming1998.github.io/tags/Node-js/"}]},{"title":"Linux git提交出现错误everything up to date的解决方法","slug":"Linux-git提交出现错误everything-up-to-date的解决方法","date":"2019-01-03T12:32:18.000Z","updated":"2019-01-06T12:53:42.837Z","comments":true,"path":"2019/01/03/Linux-git提交出现错误everything-up-to-date的解决方法/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/Linux-git提交出现错误everything-up-to-date的解决方法/","excerpt":"","text":"如果你之前没有提交过文件,而你在git push的时候出现Everything up-to-date,并且文件也没有提交上去.可能是因为你没有git add 和 git commit. git add . git commit -m &quot;test&quot; // 不添加-m 是不能直接添加message的 git pull origin master git push origin master","categories":[{"name":"git","slug":"git","permalink":"https://cuiyiming1998.github.io/categories/git/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://cuiyiming1998.github.io/tags/linux/"},{"name":"错误解决","slug":"错误解决","permalink":"https://cuiyiming1998.github.io/tags/错误解决/"},{"name":"错误","slug":"错误","permalink":"https://cuiyiming1998.github.io/tags/错误/"}]},{"title":"Linux Ionic配置","slug":"Linux-Ionic配置","date":"2019-01-03T12:30:07.000Z","updated":"2019-01-03T12:38:47.479Z","comments":true,"path":"2019/01/03/Linux-Ionic配置/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/Linux-Ionic配置/","excerpt":"","text":"查看系统版本uname -a 查看系统位数uname -m 如果是x86_64就是64位，如果是i686就是32位 安装nodejs 进入Nodejs官网下载安装包 解压安装包cd Downloads tar -xvf node-v10.14.2-linux-x64 将该目录移动到通用软件目录sudo mv node-v10.14.2-linux-x64 /opt/ 安装 npm 和 node 命令到系统命令sudo ln -s /opt/node-v6.10.3-linux-x64/bin/node /usr/local/bin/node sudo ln -s /opt/node-v6.10.3-linux-x64/bin/npm /usr/local/bin/npm 运行npm -v、node -v查看是否安装成功 搭建JAVA环境 下载jdk-8u191-linux-x64.tar.gz 解压tar -zxvf jdk-8u191-linux-x64.tar.gz 移动到opt目录下sudo mv jdk1.8.0_191 /opt/ 搭建ANDROID环境 下载android-sdk_r24.4.1-linux.tgz 解压tar -zxvf android-sdk_r24.4.1-linux.tgz 移动到optsudo mv android -sdk-linux /opt 更新（会获取到目前所有的安卓版本，文件会有点大）android-sdk-linux/tools/android update sdk --no-ui 配置环境变量 编辑profile文件sudo vim /etc/profile 在profile文件后加入如下代码export JAVA_HOME=/opt/java/jdk1.8.0_191 export ANDROID_HOME=/opt/android-sdk-linux export PATH=$JAVA_HOME/bin:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH 安装cordova ionicnpm install -g cordova ionic 完成后运行cordova、ionic查看是否安装成功如果安装太慢，可以设置淘宝镜像安装，或是使用cnpm安装 npm config set registry https://registry.npm.taobao.org","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cuiyiming1998.github.io/categories/Linux/"},{"name":"Ionic","slug":"Linux/Ionic","permalink":"https://cuiyiming1998.github.io/categories/Linux/Ionic/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://cuiyiming1998.github.io/tags/linux/"},{"name":"ionic","slug":"ionic","permalink":"https://cuiyiming1998.github.io/tags/ionic/"},{"name":"配置","slug":"配置","permalink":"https://cuiyiming1998.github.io/tags/配置/"}]},{"title":"CSS渐变与变形处理","slug":"渐变与变形处理","date":"2019-01-03T12:07:42.000Z","updated":"2019-01-06T12:54:19.170Z","comments":true,"path":"2019/01/03/渐变与变形处理/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/渐变与变形处理/","excerpt":"","text":"渐变与变形处理[TOC] 渐变效果网页中的渐变效果包括渐变背景、渐变导航、渐变按钮等 CSS3渐变分类 线性渐变，径向渐变 CSS3渐变优点 代替使用图像来实现效果，可以减少下载的时间和宽带的使用。 由浏览器生成，在放大时看起来效果更好。 线性渐变语法：background: linear-gradient(direction,color-stop1,color-stop2,...) 在一条直线上进行颜色渐变，渐变线由包含渐变图形的容器的中心点和一个角度来定义的。 linear-gradient() 函数创建一个没有内在尺寸的，表示颜色线性渐变的&lt;image&gt; 图像；它既不具有固有的或首选的尺寸，也不具有比率。它的具体尺寸将与其适用的元素尺寸匹配。 第一个参数：指定渐变方向，可以用角度或英文关键词来表示。 第一个参数省略时，默认为180edg，等同于to bottom 第二个和第三个参数，表示颜色的开始点和结束点，可以有多个颜色值。 &lt;style type=\"text/css\"> .div1{ background: linear-gradient(to bottom left,red 20%,yellow 40%,green); /* 前20%红色，20%~40%黄色，剩下的绿色 */ } &lt;/style> 重复的线性渐变语法： repeating-linear-gradient() 切角效果&lt;style> .div1{ height: 100px; width: 100px; background: linear-gradient(45deg,transparent 20px, lightgreen 0px); } &lt;/style> &lt;body> &lt;div class=\"div1\"> &lt;/div> &lt;/body> 渐变按钮&lt;style> a{ padding: 10px 15px; border-radius: 6px; color: #623f1d; font-size: 18px ; background: linear-gradient(to top, #ffce63, #fcaa35); } a:hover{ background: linear-gradient(to top, #fcaa35,#ffce63); } &lt;/style> &lt;body> &lt;a href=\"#\">渐变按钮&lt;/a> &lt;/body> 径向渐变是一种从起点到终点颜色从内到外进行圆形渐变（从中间向外拉，像圆一样）。在径向渐变中没有设置位置时，其默认颜色为均匀间隔，设置了渐变位置就会按照渐变位置去渐变。 语法：background: radial-gradient(shape at position,color1-stop,color2-stop,...) shape circle——定义渐变为圆形 ellipse——定义渐变为椭圆形 position 长度值 px（可负） 百分比 %（可负） .div1{ background:radial-gradient(50%50%,red 0%,yellow 20%,black 50%,green 80%,yellow); } .div3{ background:radial-gradient(circleat topleft, red 0%,yellow 20%,black 50%,green 80%,yellow); } CSS3变形在CSS3中提供了transform和transform-origin两个用于实现2D变换的属性。 transform属性用于实现平移、缩放、旋转和倾斜等2D变换。 transform-origin属性则是用于设置变换的中心点的。 transformtransform属性向元素应用2D或3D转换。通过转换能够对元素进行旋转、缩放、移动、倾斜或拉伸。 Chrome和Safari需要前缀-webkit- Firefox需要前缀-moz- Opera需要前缀-o- IE9需要前缀-ms- 语法： transform: none | transform-functions transform属性的属性值由值及函数组成。 移动——translate()方法translate()方法能够重新定位元素的坐标。 translateX(x)：元素仅在水平方向移动; translateY(y)：元素仅在垂直方向移动; translate(x,y)：元素在水平和垂直方向同时移动; 实例： .png) &lt;style type=\"text/css\"> .test ul { list-style:none; } .test li { float:left; width:100px; background:#CCC; margin-left:3px; line-height:30px; } .test a { display:block; text-align:center; height:30px; } .test a:link{ text-decoration: none; color: white; } .test a:hover { color:#fff; font-weight: bold; background:url(images/icon2.jpg) red no-repeat 5px 12px; text-decoration:none; transform: translate(-4px,-4px); } .test a:visited { color:#666; text-decoration:underline; } &lt;/style> &lt;body> &lt;div class=\"test\"> &lt;ul> &lt;li>&lt;a href=\"1\">首页&lt;/a>&lt;/li> &lt;li>&lt;a href=\"2\">新闻&lt;/a>&lt;/li> &lt;li>&lt;a href=\"3\">论坛&lt;/a>&lt;/li> &lt;li>&lt;a href=\"4\">博客&lt;/a>&lt;/li> &lt;li>&lt;a href=\"5\">团购&lt;/a>&lt;/li> &lt;li>&lt;a href=\"6\">微博&lt;/a>&lt;/li> &lt;/ul> &lt;/div> &lt;/body> 旋转——rotate()方法rotate()方法能够相对中心原点旋转指定的元素。 语法：transform: rotate(angle) 正角度为顺时针旋转元素 负角度为逆时针旋转元素 缩放——scale()方法scale()方法能够实现文字或图像根据中心原点进行缩放 scaleX(x) scaleY(y) scale(x,y) 绝对值大于1，代表放大。 绝对值小于1，代表缩小。 绝对值等于1，不缩放。 当值为负数时对象反转。 倾斜——skew()方法skew()方法能够倾斜指定元素。 skewX(x) skewY(y) skew(x,y)：元素水平方向和垂直方向同时倾斜；如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。 3D变形CSS3允许使用3D转换来实现元素在X轴、Y轴、Z轴方向上的变形处理。 3D旋转roteteX(angle)、rotateY(angle)、rotateZ(angle) transform-origintransform-origin属性更改变换的基点位置。 语法transform: x-axis y-axis 默认情况下，元素基点位置为元素的中心点，即X轴和Y轴的50%处。 CSS3变形进行的位移、缩放、旋转、倾斜都是以元素的基点进行变形。 多重变形对同一元素可添加多种变形效果 transform: translate(150px,200px) rotate(120deg) scale(1.5,1.5) 实例——照片墙使用纯HTML和CSS实现照片墙效果。 照片随意排列，鼠标经过时照片正放并放大。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/tags/CSS/"},{"name":"样式","slug":"样式","permalink":"https://cuiyiming1998.github.io/tags/样式/"}]},{"title":"背景与边框","slug":"背景与边框","date":"2019-01-03T12:07:33.000Z","updated":"2019-01-06T12:54:10.717Z","comments":true,"path":"2019/01/03/背景与边框/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/背景与边框/","excerpt":"","text":"背景与边框[TOC] 背景样式CSS3包含了多个新的背景属性，提供了对背景更强大的控制 background-size background-origin background-clip 使用多重背景图片 background-size规定背景图片的尺寸 语法： background-size:length | percentage | cover | contain 值 描述 length 以浮点数字和单位组成的长度值来设置背景图的高度和宽度。如果只设置一个值，第二个值会被设置成auto。 percentage 以父元素的百分比来设置背景图的高度和宽度。如果只设置一个值，第二个值会被设置成auto。 cover 保持背景图本身宽高比例。将图片缩放到正好完全覆盖所定义背景的区域。 contain 保持背景图本身宽高比例。将图片缩放到宽度和高度正好适应所定义背景的区域。 重置背景图像 .div1{ background: url(flwr.gif); background-size: 80px 80px; background-repeat: no-repeat; } .div2{ background: url(flwr.gif); background-size: 100% 100%; background-repeat: no-repeat; } background-origin规定背景图片的定位区域(background-position的参考位置) 语法： background-origin: border-box | padding-box | content-box 值 描述 border-box 从补白区域开始显示背景。 padding-box 从边框区域开始显示背景 content-box 仅在内容区域显示背景 CSS3多个背景图像CSS3允许给元素添加多个背景图像 body{ background-image: url(flwr.gif), url(tree.gif); } 利用逗号作为分隔符来同时指定多个属性值 设置多个背景图像时，注意图像的叠放顺序（第一个图像放在最上面，最后指定的文件放在最下面） background-clip规定背景的绘制区域(决定背景在哪些区域显示) 语法：background-clip: border-box | padding-box |content-box background-origin和background-clipbackground-clip: border | padding | content 指定背景在哪些区域可以显示，但与背景开始绘制的位置无关。背景的绘制的位置可以出现在不显示背景的区域，这时就相当于背景图片被不显示背景的区域裁剪了一部分。 background-origin: border | pdding | content 指定背景从哪个区域（边框、补白或内容）开始绘制。可以用此属性在边框上绘制背景，但边框上的背景能不能显示出来就要由background-clip来决定了。 CSS3边框通过CSS3能够创建圆角边框，向矩形添加阴影，使用图片来绘制边框。并且不需使用设计软件，比如PhotoShop。 圆角边框语法： border-radius: 1-4 length | % border-radius属性可以包含两个参数值，第一个值表示圆角的水平半径，第二个值表示圆角的垂直半径，两个参数通过斜线分隔。如果仅包含一个参数值，表示两个数值相同，即1/4圆角。 &lt;style type=\"text/css\"> div{ border: 5px solid blue; border-radius: 20px; background-color: skyblue; padding: 20px; width: 180px; } &lt;/style> &lt;body> &lt;div> Hello World! &lt;/div> &lt;/body> 如果要绘制的圆角边框四个角的半径互不相同时，需按左上角、右上角、右下角、左下角的顺序设置每个方向圆角的半径值 border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 图像边框border-image可以让元素的宽度或长度处于随时变化的边框统一使用一个图像文件进行绘制。 语法：border-image: url(图像文件的路径) A B C D A B C D 四个参数表示浏览器自动把图像分隔时的上边距、右边距、下边距以及左边距 &lt;style> div{ border: solid 5px; border-image: url(border.png) 18 18 18 18; width: 200px; } &lt;/style> &lt;body> &lt;div> Hello World! &lt;/div> &lt;/body> 阴影向框添加一个或多个阴影——box shadow属性语法：box-shadow: h-shadow v-shadow blur spread color inset 值 描述 h-shdow 必需，水平阴影的位置。允许负值。 v-shadow 必需，垂直阴影的位置。允许负值。 blur 可选，模糊距离。 spread 可选，阴影的尺寸。 color 可选，阴影的颜色。 inset 可选，将外部阴影改为内部阴影。 &lt;style> img{ height: 300px; border-shadow: 5px 5px; } &lt;/style>","categories":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/tags/CSS/"},{"name":"样式","slug":"样式","permalink":"https://cuiyiming1998.github.io/tags/样式/"}]},{"title":"CSS动画","slug":"CSS动画","date":"2019-01-03T12:07:03.000Z","updated":"2019-01-06T12:53:26.423Z","comments":true,"path":"2019/01/03/CSS动画/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/CSS动画/","excerpt":"","text":"CSS动画[TOC] 过渡transitionCSS3中transform属性所实现的元素变形，呈现的仅仅是一个结果。而transition实现的是一种过渡，即一种动画转换过程，如渐显，渐隐，动画快慢等。 transition通过将一个元素从一个属性值在指定的时间内平滑地过渡到另一个属性值来实现动画功能。 语法 值 描述 transition-property 规定设置过渡效果的CSS属性名称。 transition-duration 规定完成过渡效果需要的时间。默认是0。 transition-timing-function 规定过渡效果的时间曲线。默认是 ease transition-delay 规定过渡效果从何时开始。默认是0。 定义过渡属性 transition-property指定参与过渡的属性。 语法： transition-property: all | none | &lt;property>[ ,&lt;property> ] * all：默认值，表示所有可以进行过渡的CSS属性。 none：表示不进行过渡的CSS属性。 &lt;property&gt;：表示指定要进行过渡的CSS属性，可以同时指定多个属性值，用 “ , “ 分隔。 示例： div{ background-color: #ffff00; } div:hover{ background-color: #ff0000; transition-property: background-color; } 定义过渡时间 transition-duration指定过渡持续的时间，即设置从旧属性换到新属性花费的时间（以秒或毫秒计）。 语法： transition-duration: &lt;time>[,&lt;time>]* time：默认值为0，适用于所有元素以及:before、:after伪元素，如果存在多个属性值，用 “ , “ 分隔。 定义过渡延迟时间transition-delay规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。 语法： transition-delay: time time：默认值为0，适用于适用于所有元素以及:before、:after伪元素。 设置时间可以为正整数、负整数和0。非零时必须设置单位为秒s或者毫秒ms。为负数时过渡的动作会从该时间点开始显示，之前的动作被截断；为正数的时候，过渡的动作会延迟触发。 定义过渡效果规定过渡效果的速度曲线。 语法： transition-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(x1,y1,x2,y2) linear：线性效果（速度不变） ease：缓解效果（慢—快—慢） ease-in：渐显效果（慢—快） ease-out：渐隐效果（快—慢） 合写方式transition: all .5s ease-in 1s /* 分写方式 */ transition-property: all, transition-duration: .5s, transition-timing-function: ease-in, transition-delay: 1s","categories":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/tags/CSS/"},{"name":"动画","slug":"动画","permalink":"https://cuiyiming1998.github.io/tags/动画/"}]},{"title":"CSS3概述","slug":"CSS3概述","date":"2019-01-03T12:06:53.000Z","updated":"2019-01-06T12:53:18.734Z","comments":true,"path":"2019/01/03/CSS3概述/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/CSS3概述/","excerpt":"","text":"CSS3概述[TOC] CSS用于控制网页的样式和布局 CSS3是最新的CSS标准 CSS发展史CSS1包含了font的相关属性，字体、颜色、补白、基本选择器 CSS2在这个版本中开始使用样式表结构。浮动和定位、高级选择器（子选择器，相邻选择器，通用选择器） CSS3遵循模块化开发，把很多以前需要使用图片和脚本来实现的效果，只需要短短几行代码就能搞定。CSS发展史。 CSS3的新特性功能强大的选择器允许在标签中指定特定的HTML元素而不必使用多余的类、ID或者JavaScript脚本。避免在标签中添加大量的class和id属性。 新的颜色制式和透明设定RGBA和HSLA不仅可以设定色彩，还能设定元素的透明度。另外，还可以使用opacity属性定义元素的不透明度。 多栏布局不必使用多个div标签就能实现多栏布局。浏览器能解释多栏布局属性并生成多栏，让文本实现纸质报纸的多栏结构。 多背景图CSS3允许背景属性设置多个属性值，如background-size、background-position、background-originand、background-clip等，这样就可以在一个元素上添加多层背景图片。设计复杂的网页效果（如圆角、背景重叠等），不需再为文档添加多个无用的标签。 文字阴影CSS3采用并重新定义了text-shadow属性。该属性提供了一种新的跨浏览器的方案使文字看起来更醒目。 开放字体类型@font-face是最被期待的CSS3特性之一，但是它在网站上仍然没有被广泛普及，这主要受阻于字体授权和版权问题，潜入的字体很容易从网站上下载到，这是字体厂商的主要顾虑。 圆角border-radius属性可以实现不使用背景图片也能给HTML元素添加圆角。是现在使用的最多的CSS3属性之一，因为使用圆角比较美观，而且不会与设计和可用性产生冲突。 边框图片border-image属性允许在元素的边框上设定图片，丰富了边框样式。 盒子阴影box-shadow属性可以为HTML元素添加阴影而不需要使用额外的标签或背景图片。 媒体查询Media Queries模块中允许添加媒体查询表达式，用以指定媒体类型，然后根据媒体类型来选择应该使用的样式。即允许在不改变内容的情况下在样式表中选择一种页面的布局以适应不同的设备，改善用户体验。 CSS3与浏览器Firefox的替代用法：-moz- Chrome和Safari的替代用法：-webkit- IE的替代用法-ms- div{ appearance: button; -moz-appearance: button; /* 火狐的用法 */ -webkit-appearance: button; /* Chrome和Safari的用法 */ } /* 使div看上去像一个button */ CSS3选择器在CSS3中，选择器是一种模式，用于选择需要添加样式的元素。一下是CSS3版本中定义的，即： 属性选择器 兄弟选择器 伪类选择器 属性选择器在CSS3中，增加了如下的三个属性选择器，使得属性选择器有了通配符的概念。 E[att^ = \"val\"] E[att$ = \"val\"] E[att* = \"val\"] E选择符可以省略，表示匹配任意类型的元素 E[att^ = &quot;val&quot;]选择器选择名称为E的标记，且该标记定义了att属性，att属性值是以val开头的字符串。如果省略E则表示可以匹配满足条件的任意元素。 [id^ = \"sub\"]{ background-color: rgb(129,26,91); } /* 选择id是sub开头的 */ E[att$ = &quot;val&quot;]选择器选择名称为E的标记，且该标记定义了att属性，att属性值是以val结尾的字符串。如果省略E则表示可以匹配满足条件的任意元素。 [id$ = \"sub\"]{ background-color: rgb(129,26,91); } /* 选择id是sub结尾的 */ E[att* = &quot;val&quot;]选择器选择名称为E的标记，且该标记定义了att属性，att属性值是包含val的字符串。如果省略E则表示可以匹配满足条件的任意元素。 [id* = \"sub\"]{ background-color: rgb(129,26,91); } /* 选择id包含val的 */ 兄弟选择器element1 ~ element2使用~来连接前后两个选择器。选择器中的两个元素有同一个父亲，但第二个元素不必紧跟第一个元素。即找到element1后面能匹配element2的兄弟节点 #box~.long{ background: #FFF; } /* 找到id为box的元素后面class名为long的兄弟节点 */ 结构性伪类选择器伪元素选择器针对CSS3中已经定义好的伪元素使用的选择器 语法： 选择器：伪元素{属性：值} 选择器名称 说明 E:first-line 设置对象内的第一行样式。 E:first-letter 设置对象内的第一个字符样式。 E:before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用，并且必须定义content属性 E:after 设置在对象后发生的内容。用来和content属性一起使用，并且必须定义content属性。 :root选择器用于匹配文档根元素，在HTML中，根元素始终是html元素。 使用:root选择器定义的样式，对所有的页面样式生效。对于不需要该样式的元素，可以设置单独样式进行覆盖。 :not选择器对于某个结构元素使用样式但是想排除这个结构元素下面的子结构元素，让它不使用这个样式，可以使用:not选择器。 :empty选择器用来选择没有子元素或文本内容为空的元素。 :target选择器用于为页面中某个target元素（该元素的id被当做页面中的超链接来使用）指定样式。 只有用户单击了页面中的超链接，并且跳转到target元素后，:target选择器所设置的样式才会起作用。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/tags/CSS/"}]},{"title":"CSS3文本字体与颜色","slug":"文本字体与颜色","date":"2019-01-03T12:05:00.000Z","updated":"2019-01-06T12:54:27.211Z","comments":true,"path":"2019/01/03/文本字体与颜色/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/文本字体与颜色/","excerpt":"","text":"文本，字体与颜色[TOC] 文本样式CSS3包含多个新的文字特性，包括文本阴影、自动换行、使用服务器端字体等。并且不需使用设计软件，比如PhotoShop。 给文本添加阴影——text-shadow属性语法 : text-shadow:h-shadow v-shadow blur color 值 描述 h-shadow 必需。水平阴影的位置，允许负值 v-shadow 必需。垂直阴影的位置，允许负值 blur 可选。模糊距离。 color 可选。阴影的颜色。 霓虹灯效果 (设计阴影不发生偏移，同时定义阴影模糊显示) &lt;style> p{ font-weight: bold; text-shadow: 0px 0px 3px red; } &lt;/style> &lt;body> &lt;p> 霓虹灯效果; &lt;/p> &lt;/body> 指定多个阴影 可以使用text-shadow给文字指定多个阴影，并且针对每个阴影使用不同颜色，多个阴影使用逗号分隔 &lt;style> div{ text-shadow: 10px 10px black, 20px 20px red, 30px 30px blue; } &lt;/style> 定义火焰文字 定义立体文字 文本自动换行让文本自动换行——word-wrap属性设置当前行超过容器的边界时是否断开转行，默认值为normal。 语法 word-wrap:normal | break-word 值 描述 normal 只在允许的断点字换行（浏览器默认处理）。 break-word 在长单词或URL地址内部进行换行。 让文本自动换行——work-break属性可以让浏览器实现半角空格或连字符后面的换行，而且可以实现任意位置的换行。默认值为normal。 语法： word-break: normal | break-all | keep-all 值 描述 normal 使用浏览器默认换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 字体样式使用服务器端字体在CSS3中，新增了Web Fonts功能，网页中可以使用安装在服务器端的字体，它会在需要时被自动下载到用户的计算机上 实现网页中插入特殊字体的过程： 获取特殊字体 http://www.dafont.com/single-malta.font 获取@font-face所需字体格式 http://www.fontsquirrel.com/tools/webfont-generator 应用@font-face到项目中 &lt;style> @font-face{ font-family: WebFont; src: url('webfontkit/singlemalta-webfont.fff'); } h1{ font-family:WebFont; } &lt;/style> 颜色样式CSS3 增加了3种颜色值定义模式：RGBA颜色值、HSL颜色值和HSLA颜色值。 兼容：IE9+ Firefox3 Chrome Safari以及Opear10+ RGBA颜色RGBA颜色是RGB颜色值的扩展，带有一个透明度通道。 egba(red,green,blue,&lt;opacity&gt;) opacity是介于0.0(完全透明)和1.0(完全不透明)的数字。 HSL颜色HSL色彩模式是工业界的一种颜色标准，通过对色相(Hue)、饱和度(Saturation)、和亮度(Lightness)三个颜色通道的变化以及它们相互之间的叠加来获得各种颜色。 hsl(hue,saturation,lightness); 色相(Hue)是色盘上的度数(从0到360) -0是红色，120是绿色，240是蓝色。 饱和度(Saturation)表示色彩被使用了多少，或者说色彩的深浅程度、鲜艳程度。取值为0%-100%，其中0%意味着灰度，即没有使用该颜色；100%饱和度最高，即颜色最艳。 亮度(Lightness)取值为0%-100%。其中0%最暗，显示为黑色；100%最亮，显示为白色。 HSLA颜色HSLA颜色是HSL颜色的扩展，带有一个透明度通道 hsla(hue,saturation,lightness,opacity) opacity介于0.0-1.0","categories":[{"name":"CSS","slug":"CSS","permalink":"https://cuiyiming1998.github.io/categories/CSS/"}],"tags":[{"name":"CSS 样式","slug":"CSS-样式","permalink":"https://cuiyiming1998.github.io/tags/CSS-样式/"}]},{"title":"JavaScript this的四种绑定方式","slug":"JavaScript-this的四种绑定方式","date":"2019-01-03T11:15:06.000Z","updated":"2019-01-06T12:53:34.100Z","comments":true,"path":"2019/01/03/JavaScript-this的四种绑定方式/","link":"","permalink":"https://cuiyiming1998.github.io/2019/01/03/JavaScript-this的四种绑定方式/","excerpt":"","text":"JavaScript函数中this的四种绑定[TOC] this的四种绑定 默认绑定 隐式绑定 显式绑定 new绑定 1. 默认绑定当一个函数没有明确的调用对象的时候，也就是单纯作为独立函数调用的时候，将对函数的this使用默认绑定：绑定到全局的window对象 如果在严格模式下（use strict），this会指向undefined // 第一个例子 var foo = function() { console.log(this.a); } var a = 2; foo(); // 2 // 第二个例子 var foo = function() { var a =3; var inner = function() { console.log(this.a); } inner(); } var a = 2; foo(); // 2 第二个例子虽然在foo()的作用域内声明了a = 3，但它并不是一个对象，所以this最终还是指向了window对象。 2.隐式绑定函数被调用时有上下文对象，那么this会绑定这个上下文对象。 也就是： 当函数被一个对象包含的时候，我们称这个函数的this被隐式绑定到这个对象上了 // 例子 var o = { a: 2, foo: function() { console.log(this.a); } }; o.foo(); // 2 在一串对象属性引用链中，this绑定的是最内层的对象 // 例子2 var obj = { a: 1, obj2: { a:2, obj3: { a:3, getA: function() { console.log(this.a); } } } } obj.obj2.obj3.getA(); // 3 隐式丢失最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是它会应用默认绑定，把this绑定到全局对象或者undefined上 // 例子 var foo = function() { console.log(this.a); } var obj = { a:2, foo: foo } var a = 5; var bar = obj.foo; bar() // 5 obj.foo(); // 2 像这个例子，obj对象把foo函数引用传给bar的时候，会丢失this对obj的绑定。 回调函数同样也会丢失绑定。 var foo = function() { console.log(this.a); } var obj = { a: 2, foo: foo } var a = 5; setTimeout(obj.foo, 100); // 5 这种函数赋值的方式是无法将函数所绑定的this对象也传递过去的 那如果我就是想传递函数并且把所绑定的this对象也传递过去呢？那么你可以使用显式绑定，当然还有别的办法，ES6中的箭头函数，以及很常用的var self = this。 可以参考这篇文章解决隐式丢失问题的办法 3.显式绑定显式绑定式通过apply或者call函数绑定的对象。 如果你想传递函数并且把所绑定的this对象也传递过去，那么就可以使用call() fn.call(object) // fn是你调用的函数 // object是你希望绑定的对象 // 作用：即刻调用函数fn(),调用时这个函数的this指向object // 例子 var foo = function() { console.log(this.a); } var obj = { a:1 } foo.call(obj); // 1 这样做有个缺点，每次调用都会依赖call。 所以可以将他包装成函数。 var foo = function() { console.log(this.a); } var obj = { a:1 } var bar = funtion() { foo.call(obj) } bar(); 如果使用bind会更简单 var foo = function (){ console.log(this.a); } var obj = 1{ a:1 } var bar = foo.bind(obj); bar(); call和bind的区别是——在绑定到this对象参数的同时： call将立即执行该函数。 bind不执行函数，只返回一个可供执行的函数。 new绑定用new来调用函数，会自动执行下列操作： 创建一个全新的对象 这个新对象被执行[[prototype]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 // 例子 function foo(a) { this.a = a; } var bar = new foo(2); console.log(bar.a); 优先级new绑定 -&gt; 显式绑定 -&gt; 隐式绑定 -&gt; 默认绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cuiyiming1998.github.io/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://cuiyiming1998.github.io/tags/JS/"},{"name":"函数","slug":"函数","permalink":"https://cuiyiming1998.github.io/tags/函数/"}]}]}